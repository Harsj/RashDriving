Всем привет. Любому автопилоту, очевидно, нужно не только принимать решения по управлению, но и заставлять автомобиль этим решениям подчиняться. Сегодня увидим, как весьма доступными средствами доработать обычный автомобиль полностью электронным рулевым управлением (steer-by-wire). Оказывается, сам авто для разработки не очень и нужен, а большинство функционала можно с комфортом отлаживать дома или в офисе. В главных ролях всем известные компоненты из хобби-магазинов электроники.

![Электроника в сборе](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/test-bench-overview.jpg)

<cut text="И Arduino, конечно, куда же без нее."/>

Задумаемся на секунду, что нужно для системы электронного управления? Сервопривод, который может поворачивать колёса, и контроллер, чтобы сервоприводом управлять. Внезапно, всё это в большинстве современных автомобилей уже есть, и называется "усилитель рулевого управления". Традиционные чисто механические (как правило, гидравлические) усилители стремительно исчезают с рынка, уступая место узлам с электронным блоком управления (ЭБУ). А значит, задача сразу упрощается: нам остается только "уговорить" имеющийся ЭБУ усилителя выдать нужные команды на сервопривод.

Очень удобным для доработки оказался KIA Cee'd начиная с 2015 модельного года (скорее всего аналогично и его соплатформенники от KIA/Hyundai). Сошлись одновременно несколько факторов:
* Усилитель руля полностью электрический, нет возни с гидравликой, стоит копейки (относительно) на разборках. Вся нужная проводка выведена наружу и легко доступна.
* Усилитель интегрирован с рулевой колонкой, поэтому к нему есть легкий доступ на автомобиле и любая дополнительная электроника останется в салоне в тепличных условиях (в отличие от усилителей, интегрированных в рулевую рейку).
* Очень важно - есть пример успешной доработки аналогичного KIA Soul. Американская [PolySync](https://polysync.io/) разрабатывает апгрейд Soul до полностью drive-by-wire [платформы для беспилотников](http://oscc.io/), и на [их гитхабе](https://github.com/PolySync/OSCC) можно подсмотреть [много полезного](https://github.com/PolySync/OSCC/wiki).

Итак, получена в распоряжение рулевая колонка в сборе: 

![Рулевая колонка KIA Cee'd JD](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/ceed-steering-column.jpg)

Будем заставлять её крутиться. Для этого нужно создать у блока управления впечатление, что
1. Он находится в автомобиле с работающим двигателем.
2. Водитель прикладывает вращающее усилие к рулевому колесу.

Пойдем по порядку.

# Симуляция автомобиля

Нужно понять интерфейс между электронным блоком управления (ЭБУ) усилителя и остальным автомобилем. Нагуглив [электрическую схему](http://kiaceed2.ru/html/elektrousilitel.html) видим картинку:

![Интерфейс ЭУР KIA Cee'd](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/mdps-schema-cropped.png)

Из схемы видно, что физически интерфейс очень прост:
* Питание (12V постоянное) через разъем E29.
* Сигнал включенного зажигания (12V) через разъем M46.
* CAN-шина данных также через разъем M46.

Внешний вид и распиновки разъемов находим на том же сайте.

С питанием и зажиганием всё просто, берем 12V с обычного компьютерного блока питания. Но если просто подать питание и зажигание, усилитель полноценно не включится, и усиливать не будет. Дополнительно нужна информация от других блоков автомобиля: работает ли двигатель (чтобы не тратить энергию аккумулятора при выключенном), текущая скорость (чтобы делать руль "тяжелее" на скорости), наверняка что-то ещё.

Обмен данными между электронными блоками в современных автомобилях организован по шинам [CAN (Controller Area Network)](https://ru.wikipedia.org/wiki/Controller_Area_Network). Это широковещательная (у пакетов нет адресов назначения) локальная сеть на витой паре, где каждый блок может публиковать свои данные. У каждого типа данных свой идентификатор. Например, в нашем случае усилитель руля рассылает значения угла поворота руля с ID 0x2B0. Часто бывает несколько физически разделенных шин, чтобы второстепенные блоки типа контроллеров стеклоподъемников не мешались обмену между критически важными компонентами. В Cee'd используется две шины: C-CAN и B-CAN ([схема здесь](http://kiaceed2.ru/html/hod-ogni.html), в части "Информация о канале передачи данных"). На C-CAN "висят" почти все блоки с ней и будем работать.

## Выбор адаптера CAN-шины

Первым делом понадобится CAN интерфейс для компьютера. Детальный обзор возможных решений [есть например здесь](https://makezine.com/2016/04/08/car-hacking-tools-trade/), цены варьируются от десятков до сотен долларов. По устройствам у нас относительно доступны:
1. Адаптеры [в сборе с алиэкспресса](https://ru.aliexpress.com/item/usb-to-serial-adapter-can-USB-to-CAN-CAN-CAN-turn-turn-CAN-232-to-232/32425298401.html). Их не пробовал, по слухам довольно много брака и софт видимо только под Windows.
2. Arduino шилды на MCP2515/MCP2551, в основном клоны [дизайна от seeed](http://wiki.seeed.cc/CAN-BUS_Shield_V1.2/) в любом магазине ардуинной тематики. Но совмещать такой шилд надо **не с Arduino** (я так и не смог заставить связку работать на воспроизведение с нужной скоростью), а с Raspberry Pi. В приложении ниже [подробная инструкция](#rpi-can-shield-connection).
3. USB адаптер [CANHacker Baby](http://canhacker.ru/%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B/can-hacker-baby/), разработка @Artemka86. Выгодно отличается от вариантов с алиэкспресса отличной поддержкой "из первых рук" от разработчика (проверено лично, Артём подходит к делу с душой). Также плюсом является поддержка стандартного протокола LAWICEL совместимого с широким набором софта. 

Софта разного тоже много ([за обзором опять сюда](https://makezine.com/2016/04/08/car-hacking-tools-trade/)). Самый простой вариант - Linux c `can-utils` из [SocketCAN](https://en.wikipedia.org/wiki/SocketCAN), за который спасибо инженерам Volkswagen. Большой плюс SocketCAN в стандартизации - любое USB устройство с поддержкой [протокола LAWICEL (pdf)](http://www.can232.com/docs/can232_v3.pdf) видится системой как обычный сетевой интерфейс. Таким образом избегаем привязки к вендор-специфическому софту конкретного устройства. У текущей версии CANHacker есть небольшая несовместимость со стоковыми can-utils по работе с USB, поэтому берём [патченную версию отсюда](https://github.com/waiwnf/can-utils). Raspberry Pi с CAN шилдом работает со стоковым пакетом can-utils из Raspbian OS без проблем.

## Подключение к шине, запись пакетов

С подключением к индивидуальному узлу на стенде всё просто: соединяем контакт CAN-High адаптера с CAN-High автомобильного узла, CAN-Low - c CAN-Low. По стандарту между CAN-High и CAN-Low должно быть 2 замыкающих резистора по 120 Ом, на практике обычно всё работает на довольно широком интервале сопротивлений, у меня например одно на 110 Ом.

На автомобиле замыкающий резистор не нужен (они там уже стоят, чтобы шина сама по себе работала). В зависимости от модели авто, возможно придется повозиться с физическим доступом к проводке шины. Самый удобный вариант - разъём [OBD-II (on-board diagnostic)](https://en.wikipedia.org/wiki/On-board_diagnostics#OBD-II), он обязателен на всех легковых автомобилях, выпущенных в Европе с начиная 2001-2004 года и находится не дальше 60 см от рулевого колеса. На Cee'd разъём слева под рулём, за пластмасовой крышкой блока предохранителей.

![Диагностический разъём OBD-II KIA Cee'd](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/ceed-obd-ii-socket.jpg)

Распиновка OBD-II стандартизована и включает шину CAN (CANH на 6 контакте, CANL на 14). Нам повезло, корейцы пошли по пути наименьшего сопротивления и вывели C-CAN, на которой висят все важные узлы, прямо на диагностический разъём:

![Шлюзы? Не, не слышали.](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/can-obd-schema.png)

В результате на Cee'd можно прослушать весь внутренний трафик, ничего в авто не разбирая. Когда машина не твоя, а знакомые пустили повозиться - большой плюс. Но такая халява не везде. У Volkswagen например служебная CAN изолирована от OBD шлюзом, поэтому подключаться пришлось бы примерно так:

![Подключение к служебной CAN шине на Skoda Oсtavia через разъем блока управления КПП.](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/octavia-can-connection.jpg)

Подключив все контакты, поднимаем сетевой интерфейс:
```bash
$ sudo slcand -o -c -s6 -S 115200 ttyACM0 slcan0 && sleep 1 && sudo ifconfig slcan0 up
```
Проверяем, что сеть работает и данные принимаются (включив зажигание):
```bash
$ cansniffer slcan0
```
И наконец, если всё нормально, можно записывать лог:
```bash
$ candump -L slcan0 > real-car-can-log.txt
```
Здесь нужно запустить двигатель, т.к. усилитель руля включается на собственно усиление только при работающем двигателе, а нам на стенде надо, чтобы он усиливал.

## Воспроизведение записи шины на стенде

С записанным логом с авто можно возвращаться на стенд и приступать к обману нашего одинокого усилителя. Первым делом вспомним, что в автомобиле стоит свой собственный усилитель, он тоже шлёт данные в CAN шину, и эти пакеты есть и в нашем логе. Отфильтруем их, чтобы избежать конфликтов. Подключаемся к усилителю на стенде, смотрим, что он выдает:
```bash
$ $ candump slcan0
  slcan0  2B0   [5]  00 00 00 00 00
  slcan0  2B0   [5]  FF 7F FF 06 F1
  slcan0  2B0   [5]  FF 7F FF 06 C2
  slcan0  2B0   [5]  FF 7F FF 06 D3
  slcan0  2B0   [5]  FF 7F FF 06 A4
  slcan0  2B0   [5]  FF 7F FF 06 B5
  slcan0  2B0   [5]  FF 7F FF 06 86
  slcan0  2B0   [5]  FF 7F FF 06 97
  slcan0  2B0   [5]  FF 7F FF 06 68
  slcan0  5E4   [3]  00 00 00
  slcan0  2B0   [5]  FF 7F FF 06 79
  slcan0  2B0   [5]  FF 7F FF 06 4A
....
```
Видим, что рассылаются пакеты `2B0` (текущий угол поворота руля) и, реже, `5E4` (какой-то общий статус усилителя). Отфильтровываем их из общего лога:
```bash
$ cat real-car-can-log.txt | grep -v ' 2B0' | grep -v ' 5E4 ' > can-log-no-steering.txt
```
Фильтрованный лог можно подавать на воспроизведение:
```bash
% sudo ifconfig slcan0 txqueuelen 1000
$ canplayer -I can-log-no-steering.txt
```
Если всё сработало успешно, усилитель заработает, крутить рукой рулевой вал станет гораздо легче. Итак, работать в штатном режиме мы узел заставили, можно переходить к симуляции усилий на руле.

# Эмуляция усилия на руле

Крутящий момент на рулевом валу и угол поворота измеряются встроенным блоком датчиков, от которого идет жгут проводов к блоку управления усилителем:

![Провода к датчикам угла поворота руля и момента вращения на рулевом вале.](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/angle-torque-sensor-wires.jpg)

Блок управления обрабатывает сигналы датчиков и выдаёт команды сервоприводу на создание дополнительного усилия на поворот рулевого вала.

## Проверка формата сигнала датчиков

По [информации PolySync](https://github.com/PolySync/oscc/wiki/Steering), на Soul, у которого с Cee'd общая платформа, два аналоговых датчика крутящего момента. Cигнал каждого - отклонение уровня постоянного напряжения от базовых 2.5V, провода в жгуте - зеленый и синий. Проверим, что у нас то же самое:
* Размыкаем разъем на ЭБУ, пробрасываем нужные контакты через макетку и заводим на аналоговые входы arduino.
![Кто сказал колхоз?!](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/torque-voltage-check-setup.jpg)
* Загружаем [скетч](https://github.com/waiwnf/pilotguru/tree/master/sketches/voltmeter), в цикле замеряющий напряжения и печатающий их в терминал.
* Запускаем Serial Plotter в Arduino IDE, поворачиваем рулевой вал. Видим результат на графике, схема совпадает с Soul:
![График напряжения с датчиков момента силы на рулевом вале.](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/torque-sensors-voltage-check.png)
* Радуемся сэкономленному времени.

## Эмуляция сигнала датчиков

Переходим к эмуляции сигнала датчиков. Для этого поставим свой модуль в разрыв цепи между датиком и ЭБУ, будем транслировать настоящий сигнал с датчика и по команде сдвигать его на фиксированный уровень (изображая приложенное к рулевой колонке усилие). Силами одной arduino это не получится: там нет полноценного цифро-аналогового преобразователя, который мог бы выдавать постоянное напряжение. Аналоговые входы arduino нам тоже не очень подходят - хотя пинов для них целых 6, канал АЦП в контроллере только один, и его переключение между пинами занимает заметное время.

Нужно добавить к arduino внешние ЦАП/АЦП. Мне попались модули YL-40 ([описание в pdf](http://imrad.com.ua/userdata/modules/wproducts/wprod_products/135743/Arduino%20YL-40.pdf)) на основе чипа [PCF8591](https://www.nxp.com/docs/en/data-sheet/PCF8591.pdf) - на каждой по 4 канала 8-бит АЦП и 1 8-бит ЦАП. Модуль может общаться с arduino по [протоколу I2C](https://ru.wikipedia.org/wiki/I%C2%B2C). Потребуется небольшое допиливание (в буквальном смысле): китайские товарищи поставили на плату светодиод индикации напряжения на выходе ЦАП - его **обязательно** надо отсоединить. Иначе утекающий через диод ток не даст ЦАП поднять напряжение на выходе больше 4.2V (вместо штатных 5V). Диод отсоединяем, отковыривая резистор R4 с обратной стороны платы. 

![YL-40 отсоединяем диод от выхода ЦАП](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/yl-40-remove-r4.jpg)

Также на входы распаяны игрушечные нагрузки (терморезистор, фоторезистор, ещё что-то), отсоединяем их, убирая перемычки, чтобы не мешались.

![YL-40 убираем перемычки](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/03-steer-by-wire/yl-40-remove-jumpers.jpg)

С интерфейсом к arduino есть нюанс - нам нужно 2 канала ЦАП, соотвественно 2 модуля, но у них одинаковые адреса I2C (зашиты в чип). Хотя чип позволяет менять свой I2C адрес, замыкая определенные ноги на +5V вместо земли, на плате эти перемычки не разведены. Вместо перепайки возьмем костыль - две разные библиотеки I2C на arduino (стандартная Wire и [SoftI2CMaster](https://github.com/felias-fogg/SoftI2CMaster)), каждая на свою пару пинов. Получаем модули на разных шинах, конфликт пропадает.

Остальное прямолинейно - ставим модули в разрыв цепи от датчиков, соединяем с arduino, загружаем [скетч](https://github.com/waiwnf/pilotguru/tree/master/sketches/steering-fixed-torque). Подробности по распиновке подключения есть в комментариях в скетче. Остается включить всё в сборе, здесь **важна последовательность**:
1. Включаем arduino, открываем Serial Monitor. Важно запустить arduino первой, не останавливать и не прерывать. Иначе напряжение на выходах ЦАПов сбросится, ЭБУ усилителя определит ошибку сигнала с датчиков, уйдет в безопасный редим и придется все перезапускать по новой.
2. Запитываем усилитель, подключаем зажигание.
3. Запускаем воспроизведение лога CAN-шины.
4. Теперь по командам `l` и `r` через Serial Monitor усилитель будет поворачивать рулевой вал. Объявляется победа. 

<video>https://www.youtube.com/watch?v=s84M3_18pmI</video>

На сегодня всё, на очереди доработка софта (интеграция с CAN шиной, чтение оттуда текущего угла поворота и динамическое управление крутящим усилием, чтобы внешний контроллер мог задать фиксированный угол поворота руля и система его выдерживала), отработка на автомобиле (на стенде не смоделируешь сопротивление от колёс). Возможно замена 8-битных ЦАП/АЦП на 10 или 12 бит (взял первое, что под руку попалось). Рулящая нейросеть тоже в процессе, надеюсь скоро сделать пост.

Спасибо @Artemka86 за ценные консультации по работе с CAN и помощь с оборудованием.

## Ресурсы для дальнейшего погружения
1. [Car Hacking: The definitive source](http://illmatics.com/carhacking.html). Начинать можно с [Car Hacking for Poories](http://illmatics.com/car_hacking_poories.pdf), там отлично покрыты основы. Остальное тоже интересно, но с упором на несанкционированный доступ.
2. [The Car Hacker's Handbook: A Guide for the Penetration Tester](http://opengarages.org/handbook/ebook/). Больше деталей, чем в Car Hacking: The definitive source, тоже акцент на несанкционированный доступ. Если читать как первое введение в тему, надо приспособиться пропускать большие куски.
3. [Car Hacking 101: Tools of the Trade](https://makezine.com/2016/04/08/car-hacking-tools-trade/), [MCD Software](http://opengarages.org/index.php/MCD_software) - обзоры инструментов. В основном малоинтересная экзотика на мой взгляд.
4. [Open Source Car Control](https://github.com/PolySync/OSCC/) - открытая платформа для KIA Soul, в процессе разработки. Они делают полное решение (руль, акселератор, тормоза), включвя доработки по "железу" на машине (в основном для тормозов - ставятся дополнительные тормозные приводы, что-то меняется в тормозной гидравлике итд). Релиза ещё не было, но многие вещи уже можно подсмотреть.

<a name="rpi-can-shield-connection"></a>

# Бонус. Совмещаем Raspberry Pi и Arduino CAN shield

Прежде всего, внимание, **CAN шилд и raspberry pi нельзя соединять напрямую**, они не совместимы по напряжению. На Arduino UNO-совместимых платах напряжение логики 5V, а на raspberry pi только 3.3V, поэтому прямое соединение только сожжет задействованные пины.

Нам понадобятся:
* Raspberry Pi (проверялось на версии 3B).
* Arduino CAN шилд на MCP2515/MCP2551.
* Преобразователь уровня логики на 5 каналов или больше (можно 2 по 4 канала, но понадобится больше соединений). Мне [попался этот](https://tpai.ru/preobrazovateli-elektricheskogo-toka/344-preobrazovateli-elektricheskogo-toka-universalnyy-dvunapravlennyy-8-mi-kanalnyy-preobrazovatel-urovney-33v-5v-spi-i2c-uart-i-dr-.html)

Нужно завести на CAN шилд питание (5V), соединения [интерфейса данных SPI](https://ru.wikipedia.org/wiki/Serial_Peripheral_Interface) (4 пина: MOSI, MISO, SCLK, CS) и 1 пин сигнала прерывания. Всё, кроме питания, идет через преобразователь уровня, который в свою очередь тоже надо запитать.

На схемах ищем нужные пины.

Raspberry Pi:

![Raspberry Pi pinout](https://github.com/waiwnf/pilotguru/raw/master/blog/habr/03-steer-by-wire/raspberry-pi-pinout.png)

CAN шилд:

![Can shield pinout](https://github.com/waiwnf/pilotguru/raw/master/blog/habr/03-steer-by-wire/can-shield-pinout.png)

Получаем результат:
* SPI на raspberry pi 19, 21, 23, 24 (MOSI, MISO, SCLK, CS) соответствуют D11, D12, D13, D9 (или на некоторых версиях D10) на CAN шилде.
* Прерывание с D2 на шилде можно завести на любой GPIO пин raspberry, у меня это пин 22 (GPIO 25). Номер пина укажем в софте при настройке.

Соединяем через преобразователь, заводим нужные напряжения питания на каждую сторону преобразователя, получается такая лапша:

![Raspberry Pi + Arduino CAN shield](https://github.com/waiwnf/pilotguru/raw/master/blog/habr/03-steer-by-wire/raspberry-pi-with-can-shield.jpg)

Всё, кроме 5V питания и земли на шилд идёт через преобразователь:

![RPi - CAN shield converter connections labeled](https://github.com/waiwnf/pilotguru/raw/master/blog/habr/03-steer-by-wire/rpi-can-shield-logic-converter-labeled.jpg)

Переходим к настройке софта (стандартный Raspbian).
1. Включаем поддержку SPI и CAN модуля. В `/boot/config.txt` добавляем 
  ```bash
  dtparam=spi=on
  dtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25,spimaxfrequency=1000000
  dtoverlay=spi0-hw-cs
  ```
  Здесь `interrupt=25` указывает пин, на который заведено прерывание с шилда. Индексация идёт по GPIO пинам, поэтому `interrupt=25` это GPIO 25, он же пин 22 по сквозной индексации всех пинов. Также важно указать частоту интерфейса SPI `spimaxfrequency`, т.к. значение по умолчанию - 10 МГц - слишком высокое для шилда, он просто не соединится.

2. Перезагружаем raspberry pi, проверяем соединение с шилдом:
```bash
$ dmesg
...
[   12.985754] CAN device driver interface
[   13.014774] mcp251x spi0.0 can0: MCP2515 successfully initialized.
...
``` 

3. Устанавливаем `can-utils`:
```bash
$ sudo apt install can-utils
```

4. Запускаем виртуальный сетевой интерфейс:
```bash
$ sudo /sbin/ip link set can0 up type can bitrate 500000
$ sudo ifconfig can0 txqueuelen 1000
```
Вторая команда важна при воспроизведении большого количества данных с raspberry pi, то есть когда записанный на автомобиле полный лог CAN шины воспоизводим для изолированного узла на стенде. Без увеличения буфера он скорее всего переполнится, когда в логе встретится несколько CAN пакетов с маленькими интервалами, и тогда соединение зависнет.

5. Готово, можно пользоваться `candump`, `cansniffer` и всем остальным из `can-utils`.