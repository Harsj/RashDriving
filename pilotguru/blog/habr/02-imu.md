Всем привет. Продолжаем собирать автомобильный автопилот на компьютерном зрении из гитхаба и палок ([начало здесь](https://habrahabr.ru/post/325704/)). Сегодня подключаем к делу датчики движения смартфона (акселерометр, гироскоп и GPS приемник) на Android, осваиваем несложный sensor fusion и окончательно закрываем задачу сбора обучающей выборки. Бонусы - [Android приложение](https://play.google.com/store/apps/details?id=ru.pilotguru.recorder) для записи всех сенсоров синхронзированных с видео и больше часа [размеченных данных](#processed-data-torrent) в рамках импортозамещения [иностранных конкурсов](https://medium.com/udacity/challenge-2-using-deep-learning-to-predict-steering-angles-f42004a36ff3). Весь код по-прежнему [на github](https://github.com/waiwnf/pilotguru).

![MEMS гироскоп](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/mems-imu.jpg)

Это трехосные [MEMS](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D1%8D%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%BE%D0%BC%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B) акселерометр и гироскоп, они будут нам крайне полезны.

В двух словах напомню (за деталями добро пожаловать в [предыдущий пост](https://habrahabr.ru/post/325704/), что конечная цель - обучить систему, которая по кадрам видео с лобового стекла сможет выдавать управляющие воздействия для автомобиля (угол поворота руля и желаемую скорость или ускорение). Для этого нужна обучающая выборка - видео с заездов, где машиной управляет человек, и синхронизированная по времени информация об угле поворота и скорости. В современных автомобилях эти данные можно считывать через [CAN шину](https://ru.wikipedia.org/wiki/Controller_Area_Network), но надо во-первых покупать и подключать специальный CAN адаптер, а во-вторых разбираться с расшифровкой протокола и формата данных, которые у разных производителей разные. Вместо всей этой возни мы вычисляем управляющие воздействия косвенно - из сырых данных с обычного смартфона, ни к чему дополнительно не подключенного.

В прошлой серии мы научились определять угловую скорость поворота автомобиля в горизонтальной плоскости на основе только видео кадров с помощью [библиотеки](https://github.com/raulmur/ORB_SLAM2) [видео-SLAM](https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping). К сожалению, на практике эта библиотека очень неточно вычисляет *поступательную* скорость устройства. А не зная поступательную скорость, мы не можем обучить даже компонент поворота руля для автопилота по отдельности, так как угловая скорость ![\omega](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/omega.gif) зависит от комбинации степени поворота руля (эквивалентно, радиуса поворота ![r](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/r.gif)) и поступательной скорости автомобиля ![v](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/v.gif). 

![v = omega *  r](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/v-eq-omega-r.png)

Чтобы получить поступательную скорость, сегодня переключаемся с обработки видео на датчики движения, которые есть почти в любом смартфоне: GPS приемник, акселерометр и гироскоп. Посмотрим на плюсы и минусы каждого, объединим информацию и получим мгновенную скорость для каждого кадра видео. Более того, информацию о вращениях тоже возьмём с гироскопа, что позволит отказаться от более капризного оптического SLAM и нужной ему калибровки камеры смартфона. В итоге новый процесс сбора данных усох до трех "нажатий кнопки": [ставим приложение](https://play.google.com/store/apps/details?id=ru.pilotguru.recorder) на телефон - записываем трек на заезде - обрабатываем [одной командой](https://github.com/waiwnf/pilotguru#velocity-from-imu) на компьютере.

В итоге получаем покадровую аннотацию с поступательной скоростью и скоростью поворотов:

<video>https://www.youtube.com/watch?v=HvfqpzvW2E8</video>

# Доступные датчики движения

Работать будем с андроидом. Безотносительно платформы - для знающих английский [интересное видео](https://www.youtube.com/watch?v=C7JQ7Rpwn2k) о том, как информация с разных сенсоров может дополнять улучшать калибровку и уменьшать ошибки. Нас интересуют [сенсоры движения](https://developer.android.com/guide/topics/sensors/sensors_motion.html) (акселерометр и гироскоп) и [местоположения](https://developer.android.com/guide/topics/location/strategies.html) (GPS).

С точки зрения API всё просто - запрашиваем у пользователя разрешения, подписываемся на обновления, и получаем поток событий с показанием сенсора и временем измерения. Детали можно посмотреть [в исходниках](https://github.com/waiwnf/pilotguru/blob/master/mobile/android/app/src/main/java/ru/pilotguru/recorder/MainActivity.java).

Рассмотрим плюсы и минусы сенсоров.

## GPS

GPS - это, как выяснилось, 90% успеха в определении поступательной скорости, по крайней мере на относительно открытых пространствах. От GPS приходят в формате [Location](https://developer.android.com/reference/android/location/Location.html):
* Оценка абсолютного положения (широта, долгота).
* Оценка [точности координат](https://developer.android.com/reference/android/location/Location.html#getAccuracy\(\)) - радиус доверительного круга в 68% вокруг оценки. То есть в ~68% измерений настоящее положение устройства должно быть в пределах данного радиуса вокруг оценки. Как правило на более-менее открытом пространстве точность получается в пределах 3-4 м.
* Абсолютная скорость (без направления), оцененная по прошлым замеренным GPS позициям.

Огромный **плюс** GPS данных - **погрешности измерений независимы**, то есть не накапливаются со временем: на новое измерение не влияет то, сколько измерений было до этого и скакими погрешностями. Это очень важное свойство, на которое опирается весь остальной подход.

**Недостаток** же в том, что **измерения проводятся редко**, примерно 1 раз в секунду, и заметно чаще их проводить просто нет смысла - перемещение устройства всё равно было бы сопоставимо с ошибкой измерения. Как результат, во-первых, GPS данные с запозданием реагируют на изменение скорости, а во-вторых с них сложнее убирать шумы - для этого нужно смотреть на соседние по времени измерения, что ещё больше усугубляет нечеткость данных по времени. Вот пример графика скорости с GPS:

![Пример графика скорости с GPS](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/gps-only-velocity-example-350w.png)

Здесь подозрение вызывают первые 25 секунд (постоянное ускорение и вероятное запаздывание GPS измерений) и шум между 30 и 40 секундой. Для затравки, тот же график после обработки данных с акселерометра и гироскопа:

![Пример графика скорости с GPS+IMU](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/imu-gps-velocity-example-350w.png)

Как видно, есть улучшения по обоим показателям: на ускорения реагируем раньше, и выброс на 35 секунде заглажен.

## Инерциальные датчики: акселерометр и гироскоп

Инерциальные датчики замеряют ускорения, линейные (акселерометр) и центростремительные (гироскоп). Результат их измерений - оценка *изменения движения* устройства по отношению к предыдущему моменту времени. Математически это выражается в использовании [системы координат](https://developer.android.com/guide/topics/sensors/sensors_overview.html#sensors-coords) *привязанной к устройству*:

![Device coordinate system](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/axis-device.png)

[Акселерометр](https://developer.android.com/guide/topics/sensors/sensors_motion.html#sensors-motion-accel) выдает линейные ускорения вдоль трех осей устройства, [гироскоп](https://developer.android.com/guide/topics/sensors/sensors_motion.html#sensors-motion-gyro) - угловые скорости вокруг тех же трех осей.

**Плюс** инерциальных датчиков - возможность очень **частых измерений**, в 400 Гц и выше, что на порядок перекрывает частоту видеокадров в ~30 Гц. Главный **минус** - отсутствие связи с неподвижной системой координат. Датчики сопособны ихмерить только изменение относительно предыдущего положения, поэтому для расчета результатов в неподвижной системе координат их показания **нужно интегрировать** по времени, а при этом **ошибки измерений накапливаются** - чем дольше период измерения, тем больше итоговая ошибка в следующий момент времени.

Как видно, GPS и инерциальные датчики имеют зеркально противоположные достоинства и недостатки, а значит нужно объединить сильные стороны обоих источников, к чему и приступаем.

# Sensor fusion: объединяем информацию

Имея запись данных от GPS и инерциальных датчиков, требуется оценить:
1. Абсолютную поступательную скорость с высоким временным разрешением.
2. Угловую скорость вращения *вокруг вертикальной оси автомобиля* (т.е. в плоскости дороги в каждый момент времени).

Горизонтальное вращение мы уже вычисляли в [прошлом посте](https://habrahabr.ru/post/325704/), но, как выяснилось, старый способ (через анализ видео) сложнее и капризнее, чем работа напрямую с гироскопом, поэтому лучше поменять подход.

## Поступательная скорость

Казалось бы, чего уж проще. Из школьной физики мы знаем по определению

![\vec{v}(t_1) = \vec{v}(t_0) + \int_{t_0}^{t_1} \vec{a}(t) d t](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/velocity-integral-definition.gif)

Но нам нужна скорость в неподвижной системе координат, а система координат акселерометра вращается вместе с устройством. Обозначим `R` матрицу вращения из системы координат устройства в неподвижную, тогда

![\vec{v}(t_1) = \vec{v}(t_0) + \int_{t_0}^{t_1} R(t) \vec{a}_{D}(t) d t](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/velocity-integral-with-rotation.gif)

где ![\vec{a}_{D}](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/acceleration-device-axes-notation.gif) - ускорение по осям координат утсройства. В свою очередь матрицу поворота получаем просто проинтегрировав вращения, измеренные гироскопом (![W](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/w-capital.gif) - производная матрицы вращения, её можно рассчитать, зная угловые скорости вокруг трех осей):

![R(t_1) = R(t_0) + \int_{t_0}^{t_1} (I + W(t)) d t](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/rotation-integral-definition.gif)

И всё? Не тут-то было, это только для сферического акселерометра в вакууме работает. Посмотрим на реальные данные со смартфона, неподвижно лежащего на столе:

![Raw accelerometer readings per axis](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/acceleration-still-raw-per-axis-350w.png)

Наблюдения:
* Сила земного притяжения автоматически не вычитается, ведь акселерометр принципиально не может отличать эффект притяжения земли от эффекта ускорения телефона. Значит нужно вручную определять направление и делать поправку. Теоретически андроид предлагает такую поправку [на уровне ОС](https://developer.android.com/guide/topics/sensors/sensors_motion.html#sensors-motion-linear), но на практике у меня оно толком не работало.
* Суммарное ускорение/притяжение по трем осям переваливает за 10 м/с<sup>2</sup>, что очень далеко от табличных 9.81 м/с<sup>2</sup> - за 10 минут набежит 0.2 * 600 = 120 м/с = 432 км/ч.

Второй эксперимент - запишем суммарное ускорение с телефона лежащего на столе экраном вверх, а потом - экраном вниз, и сравним:

![Overall measured acceleration screen up and down comparison](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/acceleration-magnitude-diff-screen-up-down-350w.png)

Наблюдения:
* Разница свыше 0.15 м/с<sup>2</sup> просто от смены ориентации, то есть присутствует заметная систематическая ошибка в локальной системе координат.
* Постоянный шум измерений в районе 0.05 м/с<sup>2</sup>, а как видим из интегралов выше - ошибки накапливаются со временем. А когда шумы суммируются, то даже при несмещенном шуме (т.е. когда математическое ожидание измерения совпадает с истинным значением), по [центральной предельной теореме](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0) дисперсия суммы `n` измерений составит ![O\left(\sqrt{n}\right)](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/o-sqrt-n.gif).

### Модель шума и автокалибровка

Итак, чтобы получить настоящее ускорение в неподвижное системе координат, необходимы поправки к "сырым" измерениям акселерометра. Применим простую модель:

![v(t_1) = v(t_0) + \int_{t_0}^{t_1} \left( \vec{g} + R(t) \cdot \left(\vec{a}^{RAW}(t) + \vec{h} \right) \right) dt](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/accelerometer-noise-model.gif)

где
* ![\vec{a}^{RAW}](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/a-raw.gif) - сырое измерение акселерометра, в системе координат устройства.
* ![\vec{h}](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/h.gif) - компенсация систематической ошибки акселерометра, также в системе координат устройства.
* ![R](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/r-capital.gif) - матрица вращения от системы координат устройства к неподвижной системе координат.
* ![\vec{g}](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/g.gif) - постоянная сила тяготения в неподвижной системе координат.

Матрицу вращения получим интеграцией угловых скоростей с гироскопа, а вот остальные параметры неизвестны (включая ![\vec{g}](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/g.gif), т.к. неизвестна начальная ориентация смартфона). Найти калибровочные параметры помогут данные с GPS. Вспомним, что измерения GPS довольно точны. А значит **скорость, рассчитанная по инерциальным датчикам должна быть близка к скорости по данным GPS**. Формализуем эту интуицию как задачу оптимизации. Для каждого интервала между соседними GPS измерениями (порядка 1 секунды) посчитаем дистанцию, пройденную по данным инерциальных данных, и по данным GPS, и целевой функцией назначим метрику L2 по всему времени записи:

![\min_{\vec{g}, \vec{h}, \vec{v}_0} \sum_{i=1}^n \left( \left \| \sum_{k=k_i}^{k_{i+1}} (\tau_k - \tau_{k-1} )\vec{v}_k^{IMU} \right \| - (t_i - t_{i-1})v^{GPS}_i \right )^2](https://raw.githubusercontent.com/waiwnf/pilotguru/master/img/readme/calibration-objective-velocities.gif)

где
* ![i](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/i.gif) - индекс измерения GPS.
* ![k_i \dots k_{i+1}](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/k-i-to-k-i-plus-1.gif) - индексы измерения инерциальных датчиков, попадающих в промежуток между измерениями GPS `i` и `i+1`.
* ![\tau_j](https://raw.githubusercontent.com/waiwnf/pilotguru/master/img/readme/tau-j.gif) время ![j](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/j.gif)-го измерения инерциальных датчиков.

Также обозначим ![\Delta \tau_j \equiv \tau_j - \tau_{j-1}](https://raw.githubusercontent.com/waiwnf/pilotguru/master/img/readme/delta-tau-j-def.gif) и ![\Delta t_i \equiv t_i - t_{i-1}](https://raw.githubusercontent.com/waiwnf/pilotguru/master/img/readme/delta-t-i-def.gif), и подставляя поправки к сырым замерам акселерометра, получаем окончательный вид целевой функции:

![\min_{\vec{g}, \vec{h}, \vec{v}_0} \sum_{i=1}^n \left( \left \| \sum_{k=k_i}^{k_{i+1}} \Delta \tau_k \left( \vec{v}_0 + (\tau_k - \tau_0)\vec{g} + \sum_{j=1}^k \Delta \tau_j R_j \cdot (\vec{a}_j^{RAW} + \vec{h}) \right ) \right \| - v^{GPS}_i \Delta t_i \right )^2](https://raw.githubusercontent.com/waiwnf/pilotguru/master/img/readme/calibration-objective-final.gif)

Выглядит страшновато, но на самом деле это простая квадратичная функция, несложно взять производные аналитически и оптимизировать любым численным методом, например [L-BFGS](https://en.wikipedia.org/wiki/Limited-memory_BFGS).

Для начала проверим на коротком отрезке в полминуты:

![калибровка откалибровалась](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/imu-gps-velocity-short-calibration-success-350w.png)

Здесь "на глаз" не очень понятно, какой график более правильный, но можно объявить успех хотя бы в том смысле, что калибровкой удалось подобрать параметры поправок, с которыми оценки скорости с двух разных источников очень близки. Теперь попробуем тот же подход на более продолжительной записи, порядка 10 минут:

![что-то пошло не так](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/imu-gps-velocity-long-calibration-fail-350w.png)

Тут конечно полный провал. Получается, модель простых поправок недостаточна на долгих временных интервалах, то есть остались важные источники искажений, которые она не учитывает. Это могут быть
* Систематические ошибки ("уход") гироскопа.
* Накопленный со временем белый шум акселерометра и гироскопа ![O(\sqrt{t})](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/o-sqrt-t.gif) по [центральной предельной теореме](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0).
* Взаимодействие с вибрациями двигателя (через кузов автомобиля) при движении.

### Локальная автокалибровка скользящим окном

Бороться с проблемами простой модели поправок для инерциальных датчиков можно по-разному. Возможные варианты:
1. Улучшать точность, моделируя неучтенные источники ошибок (уход гироскопа, накопление белого шума).
2. Схитрить.

Мы схитрим. Ведь в конечном итоге нам интересна не сама по себе калибровочная модель, а итоговые значения скорости. А раз на коротких отрезках калибровка справляется, можно применить стандартный прием со скользящим окном:
* разбиваем полный временной интервал на перекрывающиеся короткие отрезки,
* на каждом отрезке отдельно калибруем и вычисляем скорость интегрированием,
* усредняем результат для каждого момента времени по тем отрезкам которые его включают:

![скользящее окно](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/sliding-window.png)

Конечный результат:

![Final result - long-range time series calibrated with overlapping sliding windows](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/imu-gps-velocity-sliding-window-calibrated-final-350w.png)

Объявляем успех с поступательной скоростью, возвращаемся к угловой скорости поворотов.

## Угловая скорость поворотов

Угловая скорость поворота нужна, чтобы вычислить радиус поворота (и соответственно угол поворота руля): ![r = v / \omega](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/r-eq-v-by-omega.gif). Гироскоп замеряет угловую скорость напрямую, но в трехмерном пространстве: кроме вращения вокруг вертикальной оси (yaw - собственно поворотов), в данных отражаются еще и вращения вокруг попреречной (pitch - изменение уклона дороги, проезд лежачих полицейских) и продольной (roll - заезд одной стороной в колею или яму):

![pitch-roll-yaw](https://raw.githubusercontent.com/waiwnf/pilotguru/master/img/readme/pitch-roll-yaw.png)

Нам нужно выделить из трехмерных вращений только компоненту вокруг вертикальной оси (в системе координат автомобиля). Соответственно, нужно получить направление этой оси. Для этого воспользуемся наблюдением, что величина вращения вокруг вертикальной оси гораздо больше, чем вокруг продольной и поперечной (повороты по 90 градусов - норма, а вот смена уклона и колея - к счастью, нет). А значит можно просто принять ту ось, вокруг которой общее вращение было максимальным, за вертикальную.

Математически выделить доминантную ось вращения удобно, представив каждое элементарное вращение (т.е. измерение гироскопа) в виде кватерниона. Вращение вокруг единичной оси `(x,y,z)` на угол ![\theta](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/theta.gif) представляется кватернионом

![q((x,y,z), \theta) = \begin{pmatrix} x \sin (\theta /2) \\  y \sin (\theta /2)\\  z \sin (\theta /2)\\ \cos(\theta /2) \end{pmatrix}](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/quaternion-definition.gif)

Удобство в том, что первые три компонента кватерниона характеризуют одновременно и направление оси вращения, и величину вращения. Поэтому хороший результат дает [метод главных компонент](http://www.chemometrics.ru/materials/textbooks/pca.htm), примененный просто к первым трем компонентам кватерниона. После выделения доминантной оси, получается такая картина:

![Rotations after PCA](https://raw.githubusercontent.com/waiwnf/pilotguru/master/blog/habr/02-imu/rotations-after-pca.png)

Видно, что заметно большая доля вращений проходит вокруг выделенной доминантной оси, чем вокруг остальных двух перпендикулярных ей.

Кстати, в [предыдущем посте](https://habrahabr.ru/post/325704/) тоже применялся метод главных компонент, но тогда я не сообразил применить его к вращениям напрямую, а выделял горизонтальную плоскость по трехмерной траектории (т.е. основываясь на смещениях вместо вращений). Новый способ лучше не только тем, что полностью не нуждается в информации о смещениях, но и тем, что вертикальная ось выделяется *в системе координат устройства*. То есть с новым подходом вертикальная ось - перпендикуляр к *локальной* плоскости дороги, вместо *средней* плоскости всей траектории в старом подходе. Например, теперь вертикальная ось поворачевается (вместе с автомобиле при переезде от дороги в гору к дороге под гору). В результате выделение горизонтального поворота из общего вращения стало точнее.

# Данные <a name="processed-data-torrent">

Бонусом к [коду](https://github.com/waiwnf/pilotguru) хочу поделиться [уже обработанными данными](https://github.com/waiwnf/pilotguru/raw/master/data/open/torrents/pilotguru-data-20170523.torrent) для тех, кому интересно поиграться с обучением своих моделей. В торренте больше часа сырых данных, записанных на подмосковных дорогах, плюс (в директориях `postprocessed`) результаты вычисления поступательной скорости и угловой скорости поворотов. Если воспользуетесь - будет интересно узнать о результатах!

На этом всё, в следующей серии - учимся предсказывать управляющие воздействия по видео.
